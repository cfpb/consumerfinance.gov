'use strict';

/* scripts task
   ---------------
   Bundle javascripty things!
   This task is set up to generate multiple separate bundles, from
   different sources, and to use watch when run from the default task.
*/

var gulp = require( 'gulp' );
var stream = require( 'stream' );
var gutil = require( 'gulp-util' );
var es = require( 'event-stream' );
var routesManifest = require( '../../cfgov/v1/_generated/pages.json' );

// Constants
var MOLECULE = 'molecules';
var ORGANISM = 'organisms';

// Atomic elements that have associated JavaScript files.
// TODO: This should be replaced with logic that checks for an
//       associated JS file for a atomic element name.
var LOOKUP_TABLE = {
  Expandable:       MOLECULE,
  ExpandableGroup:  ORGANISM
};

/**
 * Handle opening event of a child Expandable instance.
 * @param {Array} matches Array of strings that came from a replace method.
 * @returns {string} Uppercased second value in `matches` array.
 */
function _convertMatchToUpperCase( matches ) {
  return matches[1].toUpperCase();
}

/**
 * `CamelCase` format a `snake_case` formatted string.
 * @param {string} str The string to convert.
 * @param {boolean} isCapitalized Whether to capitalize the first letter or not.
 * @returns {string} CamelCased or camelCased string.
 */
function _convertSnakeToCamel( str, isCapitalized ) {
  isCapitalized = typeof isCapitalized === 'undefined' ? true : isCapitalized;
  var find = /(_\w)/g;

  if ( isCapitalized ) {
    return str.charAt( 0 ).toUpperCase() +
           str.slice( 1 ).replace( find, _convertMatchToUpperCase );
  }
  return str.replace( find, _convertMatchToUpperCase );
}

/**
 * @param {string} filename The filename to write.
 * @param {string} content The content to write to `filename`.
 * @returns {Object} Return a stream to gulp.
 */
function _writeStringToFile( filename, content ) {
  var src = stream.Readable( { objectMode: true } );
  src._read = function() {
    var opts = {
      cwd: '',
      base: '',
      path: filename,
      contents: new Buffer( content )
    };
    this.push( new gutil.File( opts ) );
    this.push( null );
  };
  return src;
}

/**
 * @param {Object} entry Objects from pages.json generated by Wagtail.
 * @returns {Object} Return a stream to gulp.
 */
function _processPage( entry ) {

  // The page's element array.
  var elements = entry.elements;

  // The generated JS content.
  var content = "'use strict';";

  // An individual element name. E.g. expandable_group.
  var element;
  // The element's class name. E.g. ExpandableGroup.
  var className;
  // The element's CSS selector. E.g. o-expandable-group.
  var selector;
  // The element's type. E.g. organism.
  var type;

  // Prefix for the relative path depth of the slug.
  // Used for the require() statements in the generated JS.
  var directoryDepth = ( entry.slug.match( /\//g ) || [] ).length;
  var pathDepth = '';
  for ( var s = 0; s < directoryDepth; s++ ) {
    pathDepth += '../';
  }

  // Loop through the pages and generate a JS page that
  // requires and instantiates JS instances for the elements on the page.
  for ( var i = 0, len = elements.length; i < len; i++ ) {
    element = elements[i];
    className = _convertSnakeToCamel( element );
    type = LOOKUP_TABLE[className] || LOOKUP_TABLE[className];
    if ( type ) {
      if ( type === MOLECULE ) {
        selector = 'm-';
      } else if ( type === ORGANISM ) {
        selector = 'o-';
      }
      selector += element.replace( '_', '-' );
      // Require module.
      content += 'var ' + className + '=require(\'' +
                 pathDepth + type + '/' + className + '\');';
      // Find all instances in page DOM.
      content += 'var a' + i +
                 '=document.querySelectorAll( \'.' + selector + '\');';
      // Create variable for individual atomic element.
      content += 'var e;';
      // Loop through instances.
      content += 'for(var i=0,l=a' + i + '.length;i<l;i++) {';
      // Instantiate instance of atomic element.
      content += 'e=new ' + className + '(a' + i + '[i]);';
      // Initialize instance.
      content += 'e.init();';
      // Close loop.
      content += '}';
      // TODO: The below is just for testing.
      //       Remove when this code is finalized.
      //       To test, create a page in Wagtail,
      //       add a component that requires JS,
      //       preview the page and check the console.
      content += 'console.log(\'Instantiated new ' + className + '\');';
    }
  }
  return _writeStringToFile( 'index.js', content )
    .pipe( gulp.dest( 'cfgov/unprocessed/js/routes/' + entry.slug ) );
}

gulp.task( 'buildScriptsRoutes', function() {

  // Parse Wagtail-generated JSON file.
  var files = [];
  for ( var key in routesManifest ) {
    if ( routesManifest.hasOwnProperty( key ) ) {
      files.push( routesManifest[key] );
    }
  }
  // Write JS files for Wagtail-generated pages.
  var tasks = files.map( _processPage );

  return es.merge.apply( null, tasks );
} );
