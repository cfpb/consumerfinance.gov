import importlib
import logging
import os
import re
import shutil
import subprocess
import sys
from contextlib import redirect_stdout
from io import StringIO

from django.apps import apps
from django.conf import settings
from django.contrib.staticfiles.testing import StaticLiveServerTestCase
from django.db import connection
from django.db.migrations.loader import MigrationLoader
from django.test import RequestFactory
from django.test.runner import DiscoverRunner

import wagtail

from mock import Mock
from scripts import initial_data, test_data


class TestRunner(DiscoverRunner):
    def setup_test_environment(self, **kwargs):
        super(TestRunner, self).setup_test_environment(**kwargs)

        # The frontend build generates JavaScript files which are included in
        # Django templates via {% include %} blocks. If these files don't
        # exist, Django unit tests that try to render those templates will fail
        # with a TemplateNotFound exception.

        # This mixin creates empty placeholder files to allow running of
        # backend unit tests without first needing to run the frontend build.
        # Files are only created if they don't already exist.
        PLACEHOLDER_FILES = (
            'static_built/js/modernizr.min.js',
        )

        PLACEHOLDER_STRING = (
            'Placeholder file generated by Python unit tests'
        )

        for p in PLACEHOLDER_FILES:
            filename = settings.PROJECT_ROOT.child(*p.split(os.sep))
            filename.parent.mkdir(parents=True)

            if not filename.exists():
                with open(filename, 'w') as f:
                    f.write(PLACEHOLDER_STRING)

    def teardown_test_environment(self, **kwargs):
        super(TestRunner, self).teardown_test_environment()

        # The test settings use a custom MEDIA_ROOT for tests that write files
        # to disk. We want to clean up that location after the tests run.
        shutil.rmtree(settings.MEDIA_ROOT, ignore_errors=True)

    def run_tests(self, test_labels, extra_tests=None, **kwargs):
        # Disable logging below CRITICAL during tests.
        logging.disable(logging.CRITICAL)

        return super(TestRunner, self).run_tests(
            test_labels,
            extra_tests,
            **kwargs
        )

    def setup_databases(self, **kwargs):
        dbs = super(TestRunner, self).setup_databases(**kwargs)

        # Ensure that certain key data migrations are always run, even if
        # tests are being run without migrations, e.g. through use of
        # settings.test_nomigrations.
        self.run_required_data_migrations()

        # Set up additional required test data that isn't contained in data
        # migrations, for example an admin user.
        initial_data.run()

        return dbs

    def run_required_data_migrations(self):
        if wagtail.VERSION >= (2, 0):
            if settings.MIGRATION_MODULES:
                migration_methods = (
                    (
                        'wagtail.core.migrations.'
                        '0002_initial_data',
                        'initial_data'
                    ),
                    (
                        'wagtail.core.migrations.'
                        '0025_collection_initial_data',
                        'initial_data'
                    ),
                )
            else:
                migration_methods = ()
        else:
            migration_methods = (
                (
                    'wagtail.wagtailcore.migrations.'
                    '0002_initial_data',
                    'initial_data'
                ),
                (
                    'wagtail.wagtailcore.migrations.'
                    '0025_collection_initial_data',
                    'initial_data'
                ),
            )

        loader = MigrationLoader(connection)

        for migration, method in migration_methods:
            if not self.is_migration_applied(loader, migration):
                print('applying migration {}'.format(migration))
                module = importlib.import_module(migration)
                getattr(module, method)(apps, None)

    @staticmethod
    def is_migration_applied(loader, migration):
        parts = migration.split('.')
        migration_tuple = (parts[-3], parts[-1])
        return migration_tuple in loader.applied_migrations


class AcceptanceTestRunner(TestRunner):
    def run_suite(self, **kwargs):
        gulp_command = ['gulp', 'test:acceptance:protractor']
        protractor_args = sys.argv[2:]

        if protractor_args:
            for arg in protractor_args:
                gulp_command.append('--' + arg)

        try:
            subprocess.check_call(gulp_command)
        except subprocess.CalledProcessError:
            sys.exit(1)
        finally:
            self.teardown()

    def set_env_test_url(self):
        server_thread = StaticLiveServerTestCase.server_thread
        os.environ['TEST_HTTP_HOST'] = server_thread.host
        os.environ['DJANGO_HTTP_PORT'] = str(server_thread.port)

    def setup_databases(self, **kwargs):
        dbs = super(AcceptanceTestRunner, self).setup_databases(**kwargs)
        test_data.run()
        return dbs

    def teardown(self):
        self.teardown_databases(self.dbs)
        self.teardown_test_environment()
        StaticLiveServerTestCase.tearDownClass()

    def run_tests(self, test_labels, extra_tests=None, **kwargs):
        # Disable logging below CRITICAL during tests.
        logging.disable(logging.CRITICAL)

        self.setup_test_environment()
        self.dbs = self.setup_databases()

        # Create a static server, it should start immediately.
        StaticLiveServerTestCase.setUpClass()

        # Set the environment variables used by Protractor.
        self.set_env_test_url()

        self.run_suite()

        return


class HtmlMixin(object):
    def assertHtmlRegexpMatches(self, s, r):
        s_no_right_spaces = re.sub(r'>\s*', '>', s)
        s_no_left_spaces = re.sub(r'\s*([<"])', r'\1', s_no_right_spaces)
        s_no_extra_spaces = re.sub(r'\s+', ' ', s_no_left_spaces)

        self.assertIsNotNone(
            re.search(r, s_no_extra_spaces.strip(), flags=re.DOTALL),
            '{} did not match {}'.format(s_no_extra_spaces, r)
        )

    def assertPageIncludesHtml(self, page, s):
        request = RequestFactory().get('/')
        request.user = Mock()

        rendered_html = page.serve(request).render()
        try:
            self.assertHtmlRegexpMatches(str(rendered_html), s)
        except AssertionError:
            self.fail('rendered page HTML did not match {}'.format(s))


class StdoutCapturingTestRunner(TestRunner):
    def run_suite(self, suite, **kwargs):
        captured_stdout = StringIO()
        with redirect_stdout(captured_stdout):
            return_value = super(StdoutCapturingTestRunner, self).run_suite(
                suite,
                **kwargs
            )

        if captured_stdout.getvalue():
            raise RuntimeError(
                'unit tests should avoid writing to stdout: {}'.format(
                    captured_stdout.getvalue()
                )
            )

        return return_value
