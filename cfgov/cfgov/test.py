import logging
import os
import re
import shutil
import subprocess
import sys
from contextlib import redirect_stdout
from io import StringIO

from django.conf import settings
from django.contrib.staticfiles.testing import StaticLiveServerTestCase
from django.test import RequestFactory
from django.test.runner import DiscoverRunner

from mock import Mock
from scripts import initial_data, test_data


class TestRunner(DiscoverRunner):
    def setup_test_environment(self, **kwargs):
        super(TestRunner, self).setup_test_environment(**kwargs)

        # The frontend build generates JavaScript files which are included in
        # Django templates via {% include %} blocks. If these files don't
        # exist, Django unit tests that try to render those templates will fail
        # with a TemplateNotFound exception.

        # This mixin creates empty placeholder files to allow running of
        # backend unit tests without first needing to run the frontend build.
        # Files are only created if they don't already exist.
        PLACEHOLDER_FILES = (
            'static_built/js/modernizr.min.js',
        )

        PLACEHOLDER_STRING = (
            'Placeholder file generated by Python unit tests'
        )

        for p in PLACEHOLDER_FILES:
            filename = settings.PROJECT_ROOT.child(*p.split(os.sep))
            filename.parent.mkdir(parents=True)

            if not filename.exists():
                with open(filename, 'w') as f:
                    f.write(PLACEHOLDER_STRING)

    def teardown_test_environment(self, **kwargs):
        super(TestRunner, self).teardown_test_environment()

        # The test settings use a custom MEDIA_ROOT for tests that write files
        # to disk. We want to clean up that location after the tests run.
        shutil.rmtree(settings.MEDIA_ROOT, ignore_errors=True)

    def run_tests(self, test_labels, extra_tests=None, **kwargs):
        # Disable logging below CRITICAL during tests.
        logging.disable(logging.CRITICAL)

        return super(TestRunner, self).run_tests(
            test_labels,
            extra_tests,
            **kwargs
        )

    def setup_databases(self, **kwargs):
        dbs = super(TestRunner, self).setup_databases(**kwargs)

        # Set up additional required test data that isn't contained in data
        # migrations, for example an admin user.
        initial_data.run()

        return dbs

    @staticmethod
    def is_migration_applied(loader, migration):
        parts = migration.split('.')
        migration_tuple = (parts[-3], parts[-1])
        return migration_tuple in loader.applied_migrations


class AcceptanceTestRunner(TestRunner):
    def run_suite(self, **kwargs):
        gulp_command = ['gulp', 'test:acceptance:protractor']
        protractor_args = sys.argv[2:]

        if protractor_args:
            for arg in protractor_args:
                gulp_command.append('--' + arg)

        try:
            subprocess.check_call(gulp_command)
        except subprocess.CalledProcessError:
            sys.exit(1)
        finally:
            self.teardown()

    def set_env_test_url(self):
        server_thread = StaticLiveServerTestCase.server_thread
        os.environ['TEST_HTTP_HOST'] = server_thread.host
        os.environ['DJANGO_HTTP_PORT'] = str(server_thread.port)

    def setup_databases(self, **kwargs):
        dbs = super(AcceptanceTestRunner, self).setup_databases(**kwargs)
        test_data.run()
        return dbs

    def teardown(self):
        self.teardown_databases(self.dbs)
        self.teardown_test_environment()
        StaticLiveServerTestCase.tearDownClass()

    def run_tests(self, test_labels, extra_tests=None, **kwargs):
        # Disable logging below CRITICAL during tests.
        logging.disable(logging.CRITICAL)

        self.setup_test_environment()
        self.dbs = self.setup_databases()

        # Create a static server, it should start immediately.
        StaticLiveServerTestCase.setUpClass()

        # Set the environment variables used by Protractor.
        self.set_env_test_url()

        self.run_suite()

        return


class HtmlMixin(object):
    def assertHtmlRegexpMatches(self, s, r):
        s_no_right_spaces = re.sub(r'>\s*', '>', s)
        s_no_left_spaces = re.sub(r'\s*([<"])', r'\1', s_no_right_spaces)
        s_no_extra_spaces = re.sub(r'\s+', ' ', s_no_left_spaces)

        self.assertIsNotNone(
            re.search(r, s_no_extra_spaces.strip(), flags=re.DOTALL),
            '{} did not match {}'.format(s_no_extra_spaces, r)
        )

    def assertPageIncludesHtml(self, page, s):
        request = RequestFactory().get('/')
        request.user = Mock()

        rendered_html = page.serve(request).render()
        try:
            self.assertHtmlRegexpMatches(str(rendered_html), s)
        except AssertionError:
            self.fail('rendered page HTML did not match {}'.format(s))


class StdoutCapturingTestRunner(TestRunner):
    def run_suite(self, suite, **kwargs):
        captured_stdout = StringIO()
        with redirect_stdout(captured_stdout):
            return_value = super(StdoutCapturingTestRunner, self).run_suite(
                suite,
                **kwargs
            )

        if captured_stdout.getvalue():
            raise RuntimeError(
                'unit tests should avoid writing to stdout: {}'.format(
                    captured_stdout.getvalue()
                )
            )

        return return_value
